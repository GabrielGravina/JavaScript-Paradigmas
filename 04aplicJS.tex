% Prof. Dr. Ausberto S. Castro Vera
% UENF - CCT - LCMAT - Curso de Ci\^{e}ncia da Computa\c{c}\~{a}o
% Campos, RJ,  2021
% Disciplina: Paradigmas de Linguagens de Programa\c{c}\~{a}o



\chapter{ Aplica\c{c}\~{o}es da Linguagem JavaScript}

O capítulo abaixo irá demonstrar implementações em JavaScript de aplicações ou estruturas de dados conhecidas. O código será explicado nos comentários e além disso, em alguns casos o código será feito em html, CSS e JavaScript. 


    \section{Pilha Implementação}
    \begin{lstlisting}
    	let stack = [];
    	
    	stack.push(1);
    	console.log(stack); // [1]
    	
    	stack.push(2);
    	console.log(stack); // [1,2]
    	
    	stack.push(3);
    	console.log(stack); // [1,2,3]
    	
    	stack.push(4);
    	console.log(stack); // [1,2,3,4]
    	
    	stack.push(5);
    	console.log(stack); // [1,2,3,4,5]
    \end{lstlisting}
    O conteúdo foi retirado de: \url{https://www.javascripttutorial.net/javascript-stack/}

	\subsection{Prints Pilha}
	
	
	\includegraphics[width=0.7\linewidth]{../../../../Desktop/PilhaCode}
	
	
	\includegraphics[width=1\linewidth]{../PraticaJS/Stack/Stack}


    \section{Árvore de Busca Binária}
    Código retirado de: \url{https://www.geeksforgeeks.org/implementation-binary-search-tree-javascript/}
    \begin{lstlisting}
    // Node class
    class Node
    {
    constructor(data)
    {
    this.data = data;
    this.left = null;
    this.right = null;
    }
    }
    
    // Binary Search tree class
    class BinarySearchTree
    {
    constructor()
    {
    // root of a binary search tree
    this.root = null;
    }
    
    // function to be implemented
    // insert(data)
    // remove(data)
    insert(data)
    {
    // Creating a node and initialising
    // with data
    var newNode = new Node(data);
    
    // root is null then node will
    // be added to the tree and made root.
    if(this.root === null)
    this.root = newNode;
    else
    
    // find the correct position in the
    // tree and add the node
    this.insertNode(this.root, newNode);
    }
    
    // Method to insert a node in a tree
    // it moves over the tree to find the location
    // to insert a node with a given data
    insertNode(node, newNode)
    {
    // if the data is less than the node
    // data move left of the tree
    if(newNode.data < node.data)
    {
    // if left is null insert node here
    if(node.left === null)
    node.left = newNode;
    else
    
    // if left is not null recur until
    // null is found
    this.insertNode(node.left, newNode);
    }
    
    // if the data is more than the node
    // data move right of the tree
    else
    {
    // if right is null insert node here
    if(node.right === null)
    node.right = newNode;
    else
    
    // if right is not null recur until
    // null is found
    this.insertNode(node.right,newNode);
    }
    }
    search(node, data)
    {
    // if trees is empty return null
    if(node === null)
    return null;
    
    // if data is less than node's data
    // move left
    else if(data < node.data)
    return this.search(node.left, data);
    
    // if data is less than node's data
    // move left
    else if(data > node.data)
    return this.search(node.right, data);
    
    // if data is equal to the node data
    // return node
    else
    return node;
    }
    
    // returns root of the tree
    getRootNode()
    {
    return this.root;
    }
    // finds the minimum node in tree
    // searching starts from given node
    findMinNode(node)
    {
    // if left of a node is null
    // then it must be minimum node
    if(node.left === null)
    return node;
    else
    return this.findMinNode(node.left);
    }
    // Performs postorder traversal of a tree
    postorder(node)
    {
    if(node !== null)
    {
    this.postorder(node.left);
    this.postorder(node.right);
    console.log(node.data);
    }
    }
    // Performs preorder traversal of a tree
    preorder(node)
    {
    if(node !== null)
    {
    console.log(node.data);
    this.preorder(node.left);
    this.preorder(node.right);
    }
    }
    
    // helper method that calls the
    // removeNode with a given data
    remove(data)
    {
    // root is re-initialized with
    // root of a modified tree.
    this.root = this.removeNode(this.root, data);
    }
    
    // Method to remove node with a
    // given data
    // it recur over the tree to find the
    // data and removes it
    removeNode(node, key)
    {
    
    // if the root is null then tree is
    // empty
    if(node === null)
    return null;
    
    // if data to be delete is less than
    // roots data then move to left subtree
    else if(key < node.data)
    {
    node.left = this.removeNode(node.left, key);
    return node;
    }
    
    // if data to be delete is greater than
    // roots data then move to right subtree
    else if(key > node.data)
    {
    node.right = this.removeNode(node.right, key);
    return node;
    }
    
    // if data is similar to the root's data
    // then delete this node
    else
    {
    // deleting node with no children
    if(node.left === null && node.right === null)
    {
    node = null;
    return node;
    }
    
    // deleting node with one children
    if(node.left === null)
    {
    node = node.right;
    return node;
    }
    
    else if(node.right === null)
    {
    node = node.left;
    return node;
    }
    
    // Deleting node with two children
    // minimum node of the right subtree
    // is stored in aux
    var aux = this.findMinNode(node.right);
    node.data = aux.data;
    
    node.right = this.removeNode(node.right, aux.data);
    return node;
    }
    
    // search for a node with given data
    
    }
    // Performs inorder traversal of a tree
    inorder(node)
    {
    if(node !== null)
    {
    this.inorder(node.left);
    console.log(node.data);
    this.inorder(node.right);
    }
    }
    
    
    // Helper function
    // findMinNode()
    // getRootNode()
    // inorder(node)
    // preorder(node)			
    // postorder(node)
    // search(node, data)
    }
    
    // create an object for the BinarySearchTree
    var BST = new BinarySearchTree();
    
    // Inserting nodes to the BinarySearchTree
    BST.insert(15);
    BST.insert(25);
    BST.insert(10);
    BST.insert(7);
    BST.insert(22);
    BST.insert(17);
    BST.insert(13);
    BST.insert(5);
    BST.insert(9);
    BST.insert(27);
    
    //		 15
    //		 / \
    //	 10 25
    //	 / \ / \
    //	 7 13 22 27
    //	 / \ /
    // 5 9 17
    
    var root = BST.getRootNode();
    
    // prints 5 7 9 10 13 15 17 22 25 27
    BST.inorder(root);
    
    // Removing node with no children
    BST.remove(5);
    
    
    //		 15
    //		 / \
    //	 10 25
    //	 / \ / \
    //	 7 13 22 27
    //	 \ /
    //	 9 17
    
    
    var root = BST.getRootNode();
    
    // prints 7 9 10 13 15 17 22 25 27
    BST.inorder(root);
    
    // Removing node with one child
    BST.remove(7);
    
    //		 15
    //		 / \
    //	 10 25
    //	 / \ / \
    //	 9 13 22 27
    //		 /
    //		 17
    
    
    var root = BST.getRootNode();
    
    // prints 9 10 13 15 17 22 25 27
    BST.inorder(root);
    
    // Removing node with two children
    BST.remove(15);
    
    //		 17
    //		 / \
    //	 10 25
    //	 / \ / \
    //	 9 13 22 27
    
    var root = BST.getRootNode();
    console.log("inorder traversal");
    
    // prints 9 10 13 17 22 25 27
    BST.inorder(root);
    
    console.log("postorder traversal");
    BST.postorder(root);
    console.log("preorder traversal");
    BST.preorder(root);
    
    \end{lstlisting}
    
    \subsection{BST Prints}
    
    
    \includegraphics[width=0.9\linewidth]{../../../../Desktop/BSTexec}
    


    \section{Calculadora}
    O exemplo abaixo foi feito em JavaScript com HTML e CSS e interpretado pelo navegador.
    \begin{lstlisting}
    class Calculator {
    constructor(previousOperandTextElement, currentOperandTextElement) {
    this.previousOperandTextElement = previousOperandTextElement
    this.currentOperandTextElement = currentOperandTextElement
    this.clear()
    }
    
    clear() {
    this.currentOperand = ''
    this.previousOperand = ''
    this.operation = undefined
    }
    
    delete() {
    this.currentOperand = this.currentOperand.toString().slice(0, -1)
    }
    
    appendNumber(number) {
    if (number === '.' && this.currentOperand.includes('.')) return
    this.currentOperand = this.currentOperand.toString() + number.toString()
    }
    
    chooseOperation(operation) {
    if (this.currentOperand === '') return
    if (this.previousOperand !== '') {
    this.compute()
    }
    this.operation = operation
    this.previousOperand = this.currentOperand
    this.currentOperand = ''
    }
    
    compute() {
    let computation
    const prev = parseFloat(this.previousOperand)
    const current = parseFloat(this.currentOperand)
    if (isNaN(prev) || isNaN(current)) return
    switch (this.operation) {
    case '+':
    computation = prev + current
    break
    case '-':
    computation = prev - current
    break
    case '*':
    computation = prev * current
    break
    case '/':
    computation = prev / current
    break
    default:
    return
    }
    this.currentOperand = computation
    this.operation = undefined
    this.previousOperand = ''
    }
    
    getDisplayNumber(number) {
    const stringNumber = number.toString()
    const integerDigits = parseFloat(stringNumber.split('.')[0])
    const decimalDigits = stringNumber.split('.')[1]
    let integerDisplay
    if (isNaN(integerDigits)) {
    integerDisplay = ''
    } else {
    integerDisplay = integerDigits.toLocaleString('en', { maximumFractionDigits: 0 })
    }
    if (decimalDigits != null) {
    return `${integerDisplay}.${decimalDigits}`
    } else {
    return integerDisplay
    }
    }
    
    updateDisplay() {
    this.currentOperandTextElement.innerText =
    this.getDisplayNumber(this.currentOperand)
    if (this.operation != null) {
    this.previousOperandTextElement.innerText =
    `${this.getDisplayNumber(this.previousOperand)} ${this.operation}`
    } else {
    this.previousOperandTextElement.innerText = ''
    }
    }
    }
    
    
    const numberButtons = document.querySelectorAll('[data-number]')
    const operationButtons = document.querySelectorAll('[data-operation]')
    const equalsButton = document.querySelector('[data-equals]')
    const deleteButton = document.querySelector('[data-delete]')
    const allClearButton = document.querySelector('[data-all-clear]')
    const previousOperandTextElement = document.querySelector('[data-previous-operand]')
    const currentOperandTextElement = document.querySelector('[data-current-operand]')
    
    const calculator = new Calculator(previousOperandTextElement, currentOperandTextElement)
    
    numberButtons.forEach(button => {
    button.addEventListener('click', () => {
    calculator.appendNumber(button.innerText)
    calculator.updateDisplay()
    })
    })
    
    operationButtons.forEach(button => {
    button.addEventListener('click', () => {
    calculator.chooseOperation(button.innerText)
    calculator.updateDisplay()
    })
    })
    
    equalsButton.addEventListener('click', button => {
    calculator.compute()
    calculator.updateDisplay()
    })
    
    allClearButton.addEventListener('click', button => {
    calculator.clear()
    calculator.updateDisplay()
    })
    
    deleteButton.addEventListener('click', button => {
    calculator.delete()
    calculator.updateDisplay()
    })
    
    \end{lstlisting}
    
    \subsection{Prints Calculadora}
	
	\includegraphics[width=0.9\linewidth]{../../../../Desktop/CalcCode1}
	
	
	\includegraphics[width=0.9\linewidth]{../../../../Desktop/CalcCode2}
	
	
	
	
	\includegraphics[width=0.9\linewidth]{../PraticaJS/Calculadora/Calc01}

	
	\includegraphics[width=0.9\linewidth]{../../../../Desktop/Calc02}



    \section{Implementação do QuickSort}
	O algoritmo QuickSort é feito da seguinte forma no JavaScript:
	\newline
\begin{lstlisting}

// basic implementation, where pivot is the first element
function quickSortBasic(array) {
if(array.length < 2) {
return array;
}

var pivot = array[0];
var lesserArray = [];
var greaterArray = [];

for (var i = 1; i < array.length; i++) {
if ( array[i] > pivot ) {
greaterArray.push(array[i]);
} else {
lesserArray.push(array[i]);
}
}

return quickSortBasic(lesserArray).concat(pivot, quickSortBasic(greaterArray));
}

/******************* Testing Quick sort algorithm *********************/

// Returns a random integer between min (inclusive) and max (inclusive). Using Math.round() will give a non-uniform distribution, which we dont want in this case.

function getRandomInt(min, max) {
return Math.floor(Math.random() * (max - min + 1)) + min;
// By adding 1, I am making the maximum inclusive ( the minimum is inclusive anyway). Because, the Math.random() function returns a floating-point, pseudo-random number in the range from 0 inclusive up to but not including 1
}

var arr = [];

for (var i = 0; i < 10; i++) { //initialize a random integer unsorted array
arr.push(getRandomInt(1, 100));
}

console.log("Unsorted array: ");
console.log(arr); //printing unsorted array

arr = quickSortBasic(arr, 0, arr.length - 1);
console.log("Sorted array: ");
console.log(arr);

/* Output - 
Unsorted array: 
[ 63, 95, 63, 26, 76, 19, 65, 8, 63, 26 ]
Sorted array: 
[ 8, 19, 26, 26, 63, 63, 63, 65, 76, 95 ]
[Finished in 0.1s]
*/

\end{lstlisting}
O código foi retirado de:
\url{https://javascript.plainenglish.io/quick-sort-algorithm-in-javascript-5cf5ab7d251b}


\subsection{Prints QuickSort}
	Código Fonte:
	\includegraphics[width=0.7\linewidth]{../../../../Desktop/QuickSortCode}
	
	Resultado:
	\includegraphics[width=0.9\linewidth]{../PraticaJS/QuickSort/QuickSort-print}
	
	
 \section{BubbleSort}
 Retirado de: \url{https://www.delftstack.com/howto/javascript/javascript-bubble-sort/}
 \begin{lstlisting}
 function bubbleSort(items) {
	 var length = items.length;  
	 for (var i = 0; i < length; i++) { 
		 for (var j = 0; j < (length - i - 1); j++) { 
			 if(items[j] > items[j+1]) {
				 var tmp = items[j]; 
				 items[j] = items[j+1]; 
				 items[j+1] = tmp; 
 			}
 		}        
 	}
 }
 
 var arr = [5, 4, 3, 2, 1]; 
 bubbleSort(arr);
 
 console.log(arr);
 \end{lstlisting}
 
 \subsection{BubbleSort Prints}

	\includegraphics[width=0.9\linewidth]{../../../../Desktop/BubbleSortCode}


	\includegraphics[width=0.9\linewidth]{../../../../Desktop/BubbleResult}
	
	


	